## 进程两种创建方法

### 1.第一种方法：基于fork的多进程编程

1.fork使用

```python
"""
fork.py  fork 演示
"""
import os
from time import sleep

pid = os.fork()
if pid < 0:
    print("Create process failed")
elif pid == 0:
    sleep(3)
    print("The new process")
else:
    sleep(4)
    print("The old process")

print("Fork test over")
```

2.孤儿进程与僵尸进程

>1. 孤儿进程 ： 父进程先于子进程退出，此时子进程成为孤儿进程
>
>2. 僵尸进程 ： 子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会称为 
>
>僵尸进程。
>
>3. 如何避免僵尸进程产生 
>
>使用wait函数处理子进程退出 

```python
pid,status = os.wait()
功能：在父进程中阻塞等待处理子进程退出
返回值： pid 退出的子进程的PID
status 子进程退出状态
```

> 创建二级子进程处理僵尸

```python
"""
模拟僵尸进程产生
"""
import os,sys
from time import sleep
import signal

# 信号处理僵尸进场
signal.signal(signal.SIGCHLD,signal.SIG_IGN)


pid = os.fork()
if pid < 0:
    print("Error")
elif pid == 0:
    sleep(4)
    print("Child PID:",os.getpid())
    sys.exit(2)
else:
    """
    os.wait() 处理僵尸进程
    """
    # pid,status = os.wait()
    # print("PID:",pid)
    # print("STATUS:",status) # 退出状态*256
    while True:
        pass
```



### 2.第二种方法：**multiprocessing** 模块创建进程

1.Process创建多进程

```python
"""
Process进程创建方法
"""
import multiprocessing  as mp
from time import sleep

a = 1

# 进程函数
def fun():
    print("开始一个进程")
    sleep(2)
    global a
    print("a = ",a)
    a = 10000
    print("子进程函数")

# 实例化进程对象
p = mp.Process(target=fun)
p.start()  # 启动进程 执行target绑定函数

sleep(3)
print("父进程那点事")

p.join()  # 回收进程
print("a:",a)

"""
p = os.fork()
if p == 0:
    fun()
    os._exit()
else:
    os.wait()
"""
```

2.自定义进程类

```python
"""
自定义进程类
"""
from multiprocessing import Process
from time import sleep,ctime

class MyProcess(Process):
    def __init__(self,value):
        self.value = value
        super().__init__() # 引用父类方法

    def fun1(self):
        sleep(1)
        print("第一步")

    def fun2(self):
        sleep(0.8)
        print("第二步")

    # 调用start会运行run
    def run(self):
        for i in range(self.value):
            self.fun1()
            self.fun2()

if __name__ == '__main__':
    p = MyProcess(2)
    p.start() # 运行run方法
    p.join()
```

3.进程池实现

```python
"""
进程池使用演示
"""
from multiprocessing import Pool
from time import sleep,ctime

# 进程池事件函数
def worker(msg):
    sleep(2)
    print(ctime(),'--',msg)
    return 8888



if __name__ == '__main__':
    # 创建进程池
    pool = Pool()


    # 向进程池中添加事件
    for i in range(10):
        msg = "Tedu %d"%i
        r = pool.apply_async(func=worker,
                             args=(msg,))
    
    # 关闭进程池
    pool.close()
    
    # 回收进程池
    pool.join()
    print(r.get())  # 获取进程池事件函数返回值
```

### 3.进程间通讯

```python
"""
queue_test.py
消息队列演示
"""
from multiprocessing import Queue,Process
from time import sleep
from random import randint

"""
父进程中创建IO，子进程从父进程中获取IO对象，实际上
他们操作的是同一个IO，属性相互影响
如果在各自进程中创建IO对象，那么这些IO对象互相没有
任何影响
"""


# 创建消息队列
q = Queue(3)

def handle():
    while True:
        try:
            # 获取消息
            x,y = q.get(timeout=8)
        except Exception as e:
            print(e)
            break
        else:
            print("%d+%d=%d"%(x,y,x+y))

def request():
    for i in range(6):
        sleep(randint(1,16))
        x = randint(1,100)
        y = randint(1,100)
        q.put((x,y)) #存入消息

p1 = Process(target=handle)
p2 = Process(target=request)
p1.start()
p2.start()
p1.join()
p2.join()
```











