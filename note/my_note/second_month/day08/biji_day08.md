## 复习

１．进程对象的属性

pid	　daemon:(父进程退出时，子进程随着父进程退出而退出)

２．自定义进程类

继承 Process,重写init　　和run()方法，调用start()时自动执行run()，且run是子进程

３．进程池

作用：减少不停创建消除进程时，减少消耗计算机内存

```
Pool()	apply_async	close()	join()
```

４．消息队列

```python
Queue()　	q.put()   	q.get()
IO操作不占cpu,阻塞
```

５．线程

>进程包含线程，公用进程所有资源
>
>县城是进程的分支，可以独立占用内核，
>
>1. 什么是线程
>【1】 线程被称为轻量级的进程
>【2】 线程也可以使用计算机多核资源，是多任务编程方式
>【3】 线程是系统分配内核的最小单元
>【4】 线程可以理解为进程的分支任务

## 新知识

### １．线程属性

```
t.name
t.setName()
t.getName()
t.is_alive()
t.daemon：设置主线程和分支线程
t.setDaemon()设置daemon属性值
```

### ２．自定义线程类

１．练习自己补齐run()方法

### ３．同步互斥

１．线程间通信方法

２．同步互斥机制

>同步：简单来说就是阻塞
>
>互斥：当一个进程或线程在使用资源，就加锁，直到用完后，
>
>别的进程或线程才可以用（就是一种阻塞的约定）

### ４．线程同步互斥方法

```
from threading import Event
e = Event()  ：创建线程event对象
e.wait()：阻塞等待e被set
e.set() :设置e,使wait结束阻塞
e.clear() ：使e回到未被设置
e.is_set()：查看当前e是否被设置
```

### ５．线程锁

```
from threading import Lock

lock = Lock()
lock.acquire()  :上锁，如果lock已经上锁，再次上锁就会阻塞在这里
lock.release()：解锁


with lock:	上锁
...
...
注意：with代码块结束自动解锁
```

### ６．死锁及其处理

１．产生条件

```
当前线程拥有其他线程需要的资源
当前线程等待其他线程已拥有的资源
都不放弃自己拥有的资源
```

２．练习

使用多线程，同时从多个地方拷贝文件的某一部分，

最终在本地合成一个文件

### ７．python线程GIL（全局解释器锁）

１．GIL测试结果

Single cpu:7.370370149612427　计算

Single cpu: 5.2511656284332275  io

Thread cpu 11.624666452407837   计算

 Thread cpu 7.001250743865967   io

Process cpu 2.108125925064087   计算

Process cpu 1.322871208190918　　io

### ８．进程线程的区别联系



## 作业

１．总结进程线程内容实现方法

２．面试要求：问题总结

```
1. 对进程线程怎么理解/说说进程线程的差异
2. 进程间通信知道哪些，有什么特点
3. 什么是同步互斥，你什么情况下使用，怎么用
4. 给一个情形，说说用进程还是线程，为什么
5. 问一些概念，僵尸进程的处理，GIL问题，进程
```

３．fork多进程并发

​	思考：１．有没有什么瑕疵

​				２．自己写一下handle  与　tcp_client配合测试一下















































