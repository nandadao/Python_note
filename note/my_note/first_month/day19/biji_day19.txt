


day19笔记
1.复习：
    第一门课：python基础

    python语言基础
    1.python内存管理机制：
        1.引用计数：
            每个变量存储对象地址时，引用计数都会自增1;
            每个变量与对象引用断开时，引用计数都会自减1;
            如果引用计数为0
            缺点：循环引用
        2.标记清除：扫描内存，查看是否再无法访问的内存空间，
            缺点：耗时长


        3.分代回收：将内存分为“年轻代”、“中年代”、“老年代”
                每代内存告急时，都会采用标记清除，将有用的数据升代

                内存管理机制作用：
                    1.优化内存：
                        方法：尽少产生垃圾、对象池、手动回收(慎用)

                        在我们编程的时候，尽少产生垃圾

    2.对象池
        # 对象池：每次创建对象时，都会判断池中是否具有相同对象
        #         如果有，则直接返回该对象地址
        #         如果没有，则开辟空间创建新对象
        #       优点：提高内存的利用率



    3.函数参数：
        实际参数：调用函数时
            位置实参：函数名(数据1,数据2)
                序列实参：函数名(*序列) ：拆
            关键字实参：函数(形参名1=数据1， 形参名2=数据2)   # 好处：可以指定名称传递参数
                字典实参：函数名(**字典)

        形式参数：创建函数时
            默认参数：def 函数(形参名1=默认值1， 形参名2=默认值2)
            位置形参：def 函数名(形参名1,形参名2)
            命名关键字形参：def 函数名(*, 形参名1,形参名2)
                    星号元组形参：def 函数名(*args)
                    双星号字典形参：def

2.第二门课：面向对象

    面向对象： OOA(分析)  OOD(设计)  OOP(编程)
        继承(重要):隔离变化

        软件项目生命周期：
            前期：市场
                招标、投标
            中期：开发
                项目启动 --> 项目立项报告
                需求调研 --> 需求规格说明书、需求分析说明书
                设计开发
                    1.概要设计：架构、系统功能设计、关键类、关键算法
                    2.详细设计：类成员、子类、数据、业务细节
                    3.编码：代码、自测
                整体测试：功能、性能
                试运行：
                项目验收

            后期：服务
                运维：数据备份恢复...

3.第三门课：python核心

        1.迭代器  --> 生成器
                        惰性/延迟
            def  函数名():
                    yield
            生成器 = 函数名()
            for item in 生成器：

        2.函数式编程
            函数作为参数：将核心逻辑传入函数。
            函数作为返回值：闭包 --> 装饰器

          装饰器：在不改变原有函数定义与调用情况下，为其增加新功能
                核心思想：拦截

          外层函数价值：拦截  -- > 拦截对旧功能的调用
          内层函数价值：包    -- > 将新旧功能包在一起
          合：让调用旧功能的实参数量无限
          拆：将功能实参拆分的旧功能






















========================================================
作业：
    看书
    《重构》
    《Head First 设计模式》









