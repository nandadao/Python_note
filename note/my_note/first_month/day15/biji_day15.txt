day14复习

      面向过程：关心解决问题的步骤(实现细节)
    1.面向对象：关心解决问题的人
                    类和对象：
                        类：        类别·模板
                        对象：      个体·实例
                        类和类：     行为不同
                        对象和对象：  数据不同
                        抽象：       剔除个性的、非本质的， 抽离共性、本质特征的过程。
                        语法：
                            class 类名:  # 所有单词首字母大写
                                def __init__(self,参数):
                                    self.实例变量1 = 参数
                                def 实例方法名(self, 参数):
                                    方法体
                            变量 = 类名(参数)
                            变量.实例成员

                            类方法
                            class 类名:  # 所有单词首字母大写
                                类变量1 = 参数

                                @classmethed   ***************变化点
                                def 类方法名(cls, 参数):
                                    方法体
                            类名.类成员

        1.三大特征：
            1.封装：
                数据：多个基础类型  --> 一个自定义类型(模板)
                行为：对外提供必要的功能,隐藏实现细节(注意隐藏必要数据)
                设计：[分]：        分而治之 变则疏之  高内聚  低耦合

            2.继承：
                语法：重用现有类的功能，并在此基础上进行扩展
                    class 爸爸:
                        def __init__(self, 爸爸的参数):
                            self.爸爸的实例变量 = 爸爸的参数
                        def 爸爸的实例方法(self):
                            pass
                    class 儿子(爸爸):
                        def __init__(self, 爸爸的参数, 儿子的参数):
                            super().__init__(爸爸的参数)
                            self.儿子的实例变量 = 儿子的参数
                        def 儿子的实例方法(self):
                            pass

                设计：抽象变化，统一变化，隔离变化      [隔]
                            设计角度讲：先有子再有父
                            编码角度讲：先有父再有子

            3.多态：父类的一种动作，在不同的子类上有不同的实现  [做]
                    1.调用父
                    2.执行子
                    3.重写
                价值：扩展性强，灵活度高


                    class 客户端代码:
                        def 爸爸的实例方法(self， 爸爸):
                        # 1.调用父
                            爸爸.功能1（）

                    class 爸爸:
                        def 功能1(self):
                            pass

                    class 儿子(爸爸):
                        # 3.重写
                        def 功能1(self):
                            pass


                    变量 = 客户端代码()
                    #   2.执行子
                    变量.实例方法(儿子())

        2.六大原则：
            1.开闭原则：增加新功能，不修改客户端代码                           [目标]
            2.单一原则：有且只有一个改变的原因                              [一个变化点]
            3.依赖倒置：用爹不用子                                        [找抽象]
            4.组合复用法则：继承关系用在统一变化(交通工具  --> 火车、汽车)    [优先组合复用]
                          客户端代码与变化功能的关系是组合(人 --> 交通工具)
            5.里氏替换：看见爸爸可以传递儿子；重写建议使用扩展重写                [指导继承]
            6.迪米特原则：在满足条件的基础上，传递数据越少越好                  [低耦合]


===================================================================================================
day15
1.看架构如何来的

2.模块
    通常以.py结尾
    作用：
        1.使逻辑结构更加清晰
        2.有利于多人多人合作开发

    1.导入方式：
        1.import 模块名
            导入模块时，可以起一个别名
                import module01 as m
                m.fun01()
        2.方式二：
            from module01 import fun02
            fun02()
        3.方式三：
            from module01 import *
            fun02()

3.包
    __init__.py   :目的，1.标记文件夹是包
                        2.导入包的时候__init__.py自动执行 __all___ = ["p2"]
            # 方式一
            # import package01.p1 as p
            # p.fun01()
            # 方式二
            # from package01.package02.p2 import fun02
            # fun02()
            # 方式三
            from package01.package02.p2 import *
            fun02()

            # 如果导入路径是一个包，那么需要在包的__init__.py模块中设置__all__属性

4.创建根目录时  右键Mark Directory as --- Sources Root
    就是把文件夹变蓝(很重要)


5.导入模块成功的唯一条件：                     ******

6、
    sys.path  + 导入路径: 才可以正确定位模块
__  name__变量：模块自身名字，可以判断是否为主模块

    当此模块作为主模块(第一个运行的模块)运行时，__name__绑定'__main__'，
    不是主模块，而是被其它模块导入时,存储模块名。

7.如果老子是主模块，才干活
  前台词：导入我，我可不干活
  if __name__ = "__main__":
            pass

8.时间模块
import time

        # 1.时间戳(1970年1月1日到现在经过的秒数)
        print(time.time())

        # 2.时间元组(年月日十分秒星期， 年的天，夏令时偏移量)
        print(time.localtime())
        tuple_tiem = time.localtime()
        print(tuple_tiem[3:6])   # 输出十分秒

        # 3.时间戳----> 时间元组
        print(time.localtime(157153741.733721))

        # 4.时间元组  -- > 时间戳
        print(time.mktime(tuple_tiem))

        # 5.时间元组 -- > 字符串
        # "2019年11月19日"
        print(time.strftime("%Y年%m月%d日 %H时%M分%S秒",tuple_tiem))

        # 6.字符串 --> 时间元组
        print(time.strptime("2019年11月19日 17时08分48秒","%Y年%m月%d日 %H时%M分%S秒"))


===============================================================
(可以看day14的笔记，看看六大原则是如何体现的)











