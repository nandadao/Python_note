前情回顾

1. 线程创建
   Thread()
   t.start()
   t.join()

2. 线程对象属性
   t.name   t.is_alive()   t.setDaemon()

   自定义线程类
   继承Thread  重写__init__(),run()

3. 同步互斥

   * 通过阻塞控制对共享资源的操作顺序

   Event()  set()  clear()  wait()
   Lock()  acquire()  release()

   * 死锁 ： 程序执行一直阻塞无法继续

4. GIL（全局解释器锁）

   * 解释线程的时候，同一时刻只能解释一个线程
   * CPython 线程效率低
   * 线程只适合高阻塞高延迟的IO操作

5. 进程线程的区别

6. 网络服务模型

练习： 仿照fork多进程并发逻辑，编写具有同样功能的多线程并非程序

FTP文件服务

1. 需求分析

2. 技术分析
   * 并发处理： 多线程并发
   * 数据传输： tcp传输

3. 功能模块封装

   * 基本功能封装为类

   1. 查看内容
   2. 上传
   3. 下载

4. 协议设置

   请求类型    请求内容
   列表 LIST
   上传 STOR
   下载 RETR
   退出 QUIT


5. 分模块进行逻辑分析

   网络搭建
      服务端：tcp多线程并发模型
      客户端: 链接服务端，打印命令提示界面，通过输入命令决定发送内容

   获取文件列表
      客户端： 发送请求
              得到回复
              接收文件列表
      服务端： 收到请求
              找到文件库
              发送文件列表

   下载
       客户端： 请求  得到回复   下载文件
       服务端： 接收请求   给出回复   传输文件

   上传


   退出

   * 总分结构
   * 理解并发编程带来的优势
   * 面向对象
   * 请求响应模式

作业： 1. 重点代码自己能写
      2. ftp代码自己梳理
      3. http





